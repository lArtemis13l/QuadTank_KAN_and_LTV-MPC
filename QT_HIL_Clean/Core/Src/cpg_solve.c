/*
 * Copyright 2026 Adilkhan Salkimbayev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
Auto-generated by CVXPYgen on January 03, 2026 at 23:30:15.
Content: Function definitions.
*/

#include "cpg_solve.h"
#include "cpg_workspace.h"

static cpg_int i;
static cpg_int j;

// Update user-defined parameters
void cpg_update_ref(cpg_int idx, cpg_float val){
  cpg_params_vec[idx+0] = val;
  Canon_Outdated.l = 1;
  Canon_Outdated.u = 1;
}

void cpg_update_x0(cpg_int idx, cpg_float val){
  cpg_params_vec[idx+4] = val;
  Canon_Outdated.l = 1;
  Canon_Outdated.u = 1;
}

void cpg_update_A(cpg_int idx, cpg_float val){
  cpg_params_vec[idx+8] = val;
  Canon_Outdated.A = 1;
}

void cpg_update_B(cpg_int idx, cpg_float val){
  cpg_params_vec[idx+24] = val;
  Canon_Outdated.A = 1;
}

void cpg_update_d(cpg_int idx, cpg_float val){
  cpg_params_vec[idx+32] = val;
  Canon_Outdated.l = 1;
  Canon_Outdated.u = 1;
}

// Map user-defined to canonical parameters
void cpg_canonicalize_A(){
  for(i=0; i<1324; i++){
    Canon_Params.A->x[i] = 0;
    for(j=canon_A_map.p[i]; j<canon_A_map.p[i+1]; j++){
      Canon_Params.A->x[i] += canon_A_map.x[j]*cpg_params_vec[canon_A_map.i[j]];
    }
  }
}

void cpg_canonicalize_l(){
  for(i=0; i<304; i++){
    Canon_Params.l[i] = 0;
    for(j=canon_l_map.p[i]; j<canon_l_map.p[i+1]; j++){
      Canon_Params.l[i] += canon_l_map.x[j]*cpg_params_vec[canon_l_map.i[j]];
    }
  }
}

void cpg_canonicalize_u(){
  for(i=0; i<424; i++){
    Canon_Params.u[i] = 0;
    for(j=canon_u_map.p[i]; j<canon_u_map.p[i+1]; j++){
      Canon_Params.u[i] += canon_u_map.x[j]*cpg_params_vec[canon_u_map.i[j]];
    }
  }
}

// Retrieve solver info
void cpg_retrieve_info(){
  CPG_Info.obj_val = (solver.info->obj_val);
  CPG_Info.iter = solver.info->iter;
  CPG_Info.status = solver.info->status;
  CPG_Info.pri_res = solver.info->prim_res;
  CPG_Info.dua_res = solver.info->dual_res;
}

// Solve via canonicalization, canonical solve, retrieval
void cpg_solve(){
  // Canonicalize if necessary
  if (Canon_Outdated.A) {
    cpg_canonicalize_A();
  }
  if (Canon_Outdated.l) {
    cpg_canonicalize_l();
  }
  if (Canon_Outdated.u) {
    cpg_canonicalize_u();
  }
  if (Canon_Outdated.l && Canon_Outdated.u) {
    osqp_update_data_vec(&solver, OSQP_NULL, Canon_Params.l, Canon_Params.u);
  } else {
    if (Canon_Outdated.l) {
      osqp_update_data_vec(&solver, OSQP_NULL, Canon_Params.l, OSQP_NULL);
    }
    if (Canon_Outdated.u) {
      osqp_update_data_vec(&solver, OSQP_NULL, OSQP_NULL, Canon_Params.u);
    }
  }
  if (Canon_Outdated.A) {
    osqp_update_data_mat(&solver, OSQP_NULL, 0, 0, Canon_Params.A->x, 0, Canon_Params.A->nnz);
  }
  // Solve with OSQP
  osqp_solve(&solver);
  // Retrieve results
  cpg_retrieve_info();
  // Reset flags for outdated canonical parameters
  Canon_Outdated.A = 0;
  Canon_Outdated.l = 0;
  Canon_Outdated.u = 0;
}

// Update solver settings
void cpg_set_solver_default_settings(){
  osqp_set_default_settings(solver.settings);
}

void cpg_set_solver_max_iter(cpg_int max_iter_new){
  solver.settings->max_iter = max_iter_new;
}

void cpg_set_solver_eps_abs(cpg_float eps_abs_new){
  solver.settings->eps_abs = eps_abs_new;
}

void cpg_set_solver_eps_rel(cpg_float eps_rel_new){
  solver.settings->eps_rel = eps_rel_new;
}

void cpg_set_solver_eps_prim_inf(cpg_float eps_prim_inf_new){
  solver.settings->eps_prim_inf = eps_prim_inf_new;
}

void cpg_set_solver_eps_dual_inf(cpg_float eps_dual_inf_new){
  solver.settings->eps_dual_inf = eps_dual_inf_new;
}

void cpg_set_solver_scaled_termination(cpg_int scaled_termination_new){
  solver.settings->scaled_termination = scaled_termination_new;
}

void cpg_set_solver_check_termination(cpg_int check_termination_new){
  solver.settings->check_termination = check_termination_new;
}

void cpg_set_solver_warm_starting(cpg_int warm_starting_new){
  solver.settings->warm_starting = warm_starting_new;
}
